FUNCTION  <SNR>154_WinFindBuf()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:96
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000009     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:442
Called 1 time
Total time:   0.001035
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000003     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    1              0.000001     endif
                            
                                " Find the current markers
    1   0.000172   0.000089     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    1   0.000081   0.000010     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    1   0.000064   0.000009     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    1   0.000325   0.000009     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    1   0.000338   0.000010     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    1              0.000002     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    1              0.000001     endif
                            
    5              0.000007     for l:command in l:command_list
    4              0.000017         silent! execute l:command
    5              0.000004     endfor
                            
                                " Reset the sign column color when there are no more errors.
    1              0.000003     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    1              0.000000     endif

FUNCTION  <SNR>154_ShouldClose()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:50
Called 1 time
Total time:   0.000025
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000016   0.000004     let l:val = ale#Var(a:buffer, 'open_list')
    1              0.000003     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    1              0.000003     return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))

FUNCTION  ale#c#FindLocalHeaderPaths()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:547
Called 1 time
Total time:   0.014543
 Self time:   0.000620

count  total (s)   self (s)
    1   0.013931   0.000008     let l:project_root = ale#c#FindProjectRoot(a:buffer)
                            
    1              0.000003     if empty(l:project_root)
                                    return []
    1              0.000001     endif
                            
                                " See if we can find .h files directory in the project root.
                                " If we can, that's our include directory.
    1              0.000240     if !empty(globpath(l:project_root, '*.h', 0))
                                    return [l:project_root]
    1              0.000001     endif
                            
                                " Look for .hpp files too.
    1              0.000216     if !empty(globpath(l:project_root, '*.hpp', 0))
                                    return [l:project_root]
    1              0.000000     endif
                            
                                " If we find an 'include' directory in the project root, then use that.
    1              0.000129     if isdirectory(l:project_root . '/include')
                                    return [ale#path#Simplify(l:project_root . s:sep . 'include')]
    1              0.000001     endif
                            
    1              0.000002     return []

FUNCTION  ale#linter#Get()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:373
Called 1 time
Total time:   0.000386
 Self time:   0.000226

count  total (s)   self (s)
    1              0.000002     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    2              0.000010     for l:original_filetype in split(a:original_filetypes, '\.')
    1   0.000074   0.000007         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    1   0.000046   0.000007         let l:linter_names = s:GetLinterNames(l:original_filetype)
    1   0.000061   0.000007         let l:all_linters = ale#linter#GetAll(l:filetype)
    1              0.000002         let l:filetype_linters = []
                            
    1              0.000004         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    1              0.000002             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
    1              0.000001         endif
                            
    1              0.000004         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    2              0.000003     endfor
                            
    1              0.000002     let l:name_list = []
    1              0.000002     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   10              0.000014     for l:linter in reverse(l:possibly_duplicated_linters)
    9              0.000029         if index(l:name_list, l:linter.name) < 0
    9              0.000026             call add(l:name_list, l:linter.name)
    9              0.000020             call add(l:combined_linters, l:linter)
    9              0.000006         endif
   10              0.000009     endfor
                            
    1              0.000003     return reverse(l:combined_linters)

FUNCTION  <SNR>133_Lint()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:99
Called 1 time
Total time:   4.825792
 Self time:   0.000069

count  total (s)   self (s)
                                " Use the filetype from the buffer
    1              0.000004     let l:filetype = getbufvar(a:buffer, '&filetype')
    1   0.000395   0.000009     let l:linters = ale#linter#Get(l:filetype)
    1   0.000051   0.000008     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    1              0.000002     let g:ale_want_results_buffer = a:buffer
    1   0.000023   0.000017     silent doautocmd <nomodeline> User ALEWantResults
    1              0.000002     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    1              0.000004     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    1              0.000001     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    1              0.000006     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    1   4.825297   0.000009     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:28
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000002     let l:found = 0
                            
    1              0.000004     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    1              0.000001     endfor
                            
    1              0.000001     if !l:found
    1              0.000003         call add(a:info.active_linter_list, a:linter)
    1              0.000000     endif

FUNCTION  <SNR>153_GroupLoclistItems()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:261
Called 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000002     let l:grouped_items = []
    1              0.000002     let l:last_lnum = -1
                            
    3              0.000003     for l:obj in a:loclist
    2              0.000002         if l:obj.bufnr != a:buffer
                                        continue
    2              0.000002         endif
                            
                                    " Create a new sub-List when we hit a new line.
    2              0.000003         if l:obj.lnum != l:last_lnum
    2              0.000006             call add(l:grouped_items, [])
    2              0.000000         endif
                            
    2              0.000007         call add(l:grouped_items[-1], l:obj)
    2              0.000004         let l:last_lnum = l:obj.lnum
    3              0.000003     endfor
                            
    1              0.000002     return l:grouped_items

FUNCTION  <SNR>85_dir()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:231
Called 2 times
Total time:   0.000822
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000822   0.000031   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>119_expand()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:349
Called 8 times
Total time:   0.001830
 Self time:   0.001674

count  total (s)   self (s)
    8              0.000012   let components = []
    8              0.000013   let expanded = []
    8              0.000011   let indices = []
    8              0.000013   let prevtype = ''
    8              0.000012   let previndex = -1
    8              0.000010   let xs = []
    8   0.000555   0.000399   call map(deepcopy(a:components), 'map(v:val, "extend(xs, s:convert(v:val, ''" . v:key . "''))")')
   30              0.000062   for [component, expand, type, index] in xs
   22              0.000041     if prevtype !=# type
   14              0.000073       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
   14              0.000011       endfor
   14              0.000036       call add(indices, type)
   14              0.000032       call add(components, [])
   14              0.000031       call add(expanded, [])
   22              0.000018     endif
   22              0.000077     call extend(components[-1], component)
   22              0.000124     call extend(expanded[-1], repeat([expand], len(component)))
   22              0.000040     let prevtype = type
   22              0.000036     let previndex = index
   30              0.000030   endfor
    8              0.000048   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
    8              0.000008   endfor
    8              0.000035   call add(indices, string(len(a:components)))
    8              0.000018   return [components, expanded, indices]

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:184
Called 1 time
Total time:   0.005250
 Self time:   0.000107

count  total (s)   self (s)
    1   0.000019   0.000007     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000001     if g:ale_set_signs
    1   0.001047   0.000012         call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.000047   0.000006         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000003     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000001     if g:ale_virtualtext_cursor == 2
                                    call ale#virtualtext#SetTexts(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000483   0.000006             call ale#cursor#EchoCursorWarning()
    1              0.000000         endif
                            
    1              0.000001         if g:ale_virtualtext_cursor == 1
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000001         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000005         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000005         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.001150   0.000009         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.002446   0.000009         silent doautocmd <nomodeline> User ALELintPost
    1              0.000000     endif

FUNCTION  <SNR>144_GetAliasedFiletype()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:300
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000005     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    1              0.000005     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    1              0.000001     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    4              0.000009     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    3              0.000007         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
    3              0.000003         endif
    4              0.000002     endfor
                            
    1              0.000002     return a:original_filetype

FUNCTION  <lambda>11()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/clangd.vim:16
Called 1 time
Total time:   0.000025
 Self time:   0.000005

count  total (s)   self (s)
                            return ale#Var(b, 'c_clangd_executable')

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/history.vim:58
Called 1 time
Total time:   0.000062
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000058   0.000007     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000002     let l:obj.output = a:output

FUNCTION  <lambda>16()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/cquery.vim:23
Called 1 time
Total time:   0.000026
 Self time:   0.000006

count  total (s)   self (s)
                            return ale#Var(b, 'c_cquery_executable')

FUNCTION  <lambda>17()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/flawfinder.vim:19
Called 1 time
Total time:   0.000020
 Self time:   0.000004

count  total (s)   self (s)
                            return ale#Var(b, 'c_flawfinder_executable')

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:250
Called 1 time
Total time:   0.000083
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005     if exists('*sign_getplaced')
    1   0.000077   0.000012         return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                else
                                    let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                    return ale#sign#ParseSigns(l:line_list)
                                endif

FUNCTION  ale#handlers#cspell#GetExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/cspell.vim:5
Called 1 time
Total time:   0.010836
 Self time:   0.000184

count  total (s)   self (s)
    1   0.010835   0.000183     return ale#path#FindExecutable(a:buffer,    'cspell', [        'node_modules/.bin/cspell',        'node_modules/cspell/bin.js',    ])

FUNCTION  <SNR>155_StopCursorTimer()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/cursor.vim:65
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000007     if s:cursor_timer != -1
    1              0.000003         call timer_stop(s:cursor_timer)
    1              0.000001         let s:cursor_timer = -1
    3              0.000002     endif

FUNCTION  <SNR>153_PriorityCmd()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:154
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000004     if s:supports_sign_groups
    2              0.000006         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:144
Called 1 time
Total time:   0.014696
 Self time:   0.000172

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                              " *               -3 - assume unchanged
                            
    1   0.000133   0.000110   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    1   0.001226   0.000024   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args. ' ls-files -v --error-unmatch --full-name -z -- '. gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    1   0.000014   0.000012   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    1              0.000005     let handler = copy(s:set_path_handler)
    1              0.000002     let handler.continuation = a:continuation
    1   0.013307   0.000010     call gitgutter#async#execute(cmd, a:bufnr, handler)
    1              0.000001     return 'async'
                              endif
                            
                              let listing = gitgutter#utility#system(cmd)
                            
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                return
                              endif
                            
                              let listing = s:strip_trailing_new_line(listing)
                              let [status, path] = [listing[0], listing[2:]]
                              if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                              endif

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:118
Called 2 times
Total time:   0.000097
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000004     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
    4              0.000006     for l:item in a:sublist
    2   0.000043   0.000015         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
    2              0.000003         if l:item_priority > l:priority
    2              0.000003             let l:priority = l:item_priority
    2              0.000001         endif
    4              0.000003     endfor
                            
    2              0.000004     if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
    2              0.000002     endif
                            
    2              0.000004     if l:priority is# g:ale#util#warning_priority
    2              0.000002         return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  lightline#update()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:13
Called 2 times
Total time:   0.004784
 Self time:   0.000342

count  total (s)   self (s)
    2   0.000110   0.000096   if s:skip() | return | endif
    2              0.000003   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
    2              0.000001   endif
    2              0.000005   if s:lightline.enable.statusline
    2              0.000006     let w = winnr()
    2   0.004574   0.000146     let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
    6              0.000012     for n in range(1, winnr('$'))
    4              0.000044       call setwinvar(n, '&statusline', s[n!=w])
    6              0.000006     endfor
    2              0.000001   endif

FUNCTION  ale#command#SetCwd()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:34
Called 1 time
Total time:   0.000021
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000017   0.000006     call ale#command#InitData(a:buffer)
    1              0.000003     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/lsp_linter.vim:429
Called 3 times
Total time:   0.100009
 Self time:   0.000447

count  total (s)   self (s)
    3              0.000006     let l:command = ''
    3              0.000004     let l:address = ''
    3   0.063798   0.000178     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    3              0.000010     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    call ale#lsp_linter#AddErrorMessage(a:linter.name, "Failed to find project root, language server won't start.")
                            
                                    return 0
    3              0.000003     endif
                            
    3              0.000023     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    3              0.000007     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
    3              0.000001     endif
                            
    3   0.000149   0.000033     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    3   0.035949   0.000123     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  <SNR>119_subseparator()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:296
Called 8 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
    8              0.000048   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
    8              0.000391   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
    8              0.000106   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  <SNR>148_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:487
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    1              0.000002     let l:name_map = {}
                            
   10              0.000010     for l:linter in a:linters
    9              0.000021         let l:name_map[l:linter.name] = 1
   10              0.000007     endfor
                            
    1              0.000017     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>154_SetListsImpl()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:100
Called 1 time
Total time:   0.000886
 Self time:   0.000425

count  total (s)   self (s)
    1              0.000166     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000002     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    1              0.000002     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    1   0.000018   0.000009         let l:ids = s:WinFindBuf(a:buffer)
                            
    1   0.000132   0.000007         let l:loclist = s:Deduplicate(a:loclist)
                            
    2              0.000004         for l:id in l:ids
    1              0.000005             if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
    1              0.000001             else
    1   0.000340   0.000101                 call setloclist(l:id, s:FixList(a:buffer, l:loclist))
    1              0.000006                 call setloclist(l:id, [], 'r', {'title': l:title})
    1              0.000001             endif
    2              0.000002         endfor
    1              0.000001     endif
                            
                                " Save the current view before opening/closing any window
    1              0.000007     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " ShouldOpen() checks if the current buffer has enough problems to be
                                " opened.
    1   0.000036   0.000009     if s:ShouldOpen(a:buffer, len(a:loclist))
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    1              0.000001     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000019   0.000007     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000056   0.000007         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000001     endif

FUNCTION  ale#path#FindExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/path.vim:102
Called 1 time
Total time:   0.010652
 Self time:   0.000044

count  total (s)   self (s)
    1   0.000027   0.000010     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
    1              0.000001     endif
                            
    1   0.010581   0.000013     let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
    1              0.000002     if !empty(l:nearest)
                                    return l:nearest
    1              0.000000     endif
                            
    1   0.000033   0.000010     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>148_GetLintFileValues()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:617
Called 1 time
Total time:   4.825004
 Self time:   0.000378

count  total (s)   self (s)
    1              0.000002     let l:deferred_list = []
    1              0.000002     let l:new_slots = []
                            
   10              0.000016     for [l:lint_file, l:linter] in a:slots
    9   0.000094   0.000062         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
    9              0.000009         endwhile
                            
    9   0.000168   0.000132         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
    9              0.000007         else
                                        " If we have the value now, coerce it to 0 or 1.
    9              0.000017             let l:lint_file = l:lint_file is 1
    9              0.000007         endif
                            
    9              0.000030         call add(l:new_slots, [l:lint_file, l:linter])
   10              0.000007     endfor
                            
    1              0.000002     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    1              0.000001     else
    1   4.824563   0.000005         call a:Callback(l:new_slots)
    1              0.000001     endif

FUNCTION  <SNR>148_RunLinters()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:648
Called 1 time
Total time:   4.824545
 Self time:   0.000366

count  total (s)   self (s)
    1   0.000129   0.000010     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    1   0.000075   0.000010     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    1   0.000019   0.000007     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1   0.000015   0.000011     silent doautocmd <nomodeline> User ALELintPre
                            
   10              0.000028     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
    9              0.000020         if !l:lint_file || a:should_lint_file
    7   4.824134   0.000155             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
    1              0.000002                 let l:can_clear_results = 0
    7              0.000008             endif
    2              0.000002         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
    2              0.000004             let l:can_clear_results = 0
    9              0.000006         endif
   10              0.000011     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    1              0.000001     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    1              0.000001     elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    1              0.000000     endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter.vim:21
Called 1 time
Total time:   0.016246
 Self time:   0.000060

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    1   0.000027   0.000010   if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
                                call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
    1              0.000001   endif
                            
    1   0.001424   0.000008   if gitgutter#utility#is_active(a:bufnr)
                            
    1              0.000005     if has('patch-7.4.1559')
    1              0.000008       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    1              0.000001     endif
    1   0.014762   0.000009     let how = s:setup_path(a:bufnr, l:Callback)
    1              0.000005     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    1              0.000001       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter assume unchanged/
                                    call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif

FUNCTION  <SNR>85_exists_file()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:240
Called 1 time
Total time:   0.000830
 Self time:   0.000333

count  total (s)   self (s)
    1   0.000829   0.000332   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/lsp_linter.vim:498
Called 3 times
Total time:   0.100054
 Self time:   0.000045

count  total (s)   self (s)
    3   0.100052   0.000043     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  <SNR>106_Remove_Matches()
    Defined: /usr/share/vim/vim82/plugin/matchparen.vim:197
Called 3 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    3              0.000017   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000006     silent! call matchdelete(3)
    2              0.000004     let w:paren_hl_on = 0
    3              0.000003   endif

FUNCTION  FugitiveActualDir()
    Defined: ~/.vim_runtime/sources_non_forked/vim-fugitive/plugin/fugitive.vim:273
Called 16 times
Total time:   0.001255
 Self time:   0.000386

count  total (s)   self (s)
   16   0.000992   0.000123   let dir = call('FugitiveGitDir', a:000)
   16              0.000032   if empty(dir)
                                return ''
   16              0.000010   endif
   16              0.000045   if !has_key(s:resolved_git_dirs, dir)
                                let s:resolved_git_dirs[dir] = s:ResolveGitDir(dir)
   16              0.000010   endif
   16              0.000072   return empty(s:resolved_git_dirs[dir]) ? dir : s:resolved_git_dirs[dir]

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:101
Called 1 time
Total time:   0.000037
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000037   0.000010   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>154_Deduplicate()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:57
Called 1 time
Total time:   0.000125
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000001     let l:list = a:list
                            
    1   0.000081   0.000017     call sort(l:list, function('ale#util#LocItemCompareWithText'))
    1   0.000039   0.000009     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
    1              0.000002     return l:list

FUNCTION  <lambda>8()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/cc.vim:60
Called 1 time
Total time:   4.649157
 Self time:   0.000009

count  total (s)   self (s)
                            return ale#c#RunMakeCommand(b, function('ale_linters#c#cc#GetCommand'))

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:32
Called 5 times
Total time:   0.000623
 Self time:   0.000482

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    5              0.000025     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
    5              0.000004     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    5              0.000020     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
    5              0.000003     endif
                            
    5              0.000023     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    5              0.000009     if l:filetype is# ''
                                    return 1
    5              0.000003     endif
                            
                                " Do nothing for diff buffers.
    5              0.000016     if getbufvar(a:buffer, '&diff')
                                    return 1
    5              0.000004     endif
                            
                                " Do nothing for blacklisted files.
    5              0.000029     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
    5              0.000004     endif
                            
                                " Do nothing if running from command mode.
    5              0.000018     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
    5              0.000004     endif
                            
    5              0.000026     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    5              0.000009     if l:filename is# '.'
                                    return 1
    5              0.000002     endif
                            
                                " Don't start linting and so on when an operator is pending.
    5   0.000051   0.000029     if ale#util#Mode(1) is# 'no'
                                    return 1
    5              0.000004     endif
                            
                                " Do nothing if running in the sandbox.
    5   0.000087   0.000023     if ale#util#InSandbox()
                                    return 1
    5              0.000004     endif
                            
                                " Do nothing if the file is too large.
    5   0.000082   0.000027     if ale#FileTooLarge(a:buffer)
                                    return 1
    5              0.000001     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    5              0.000058     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
    5              0.000004     endif
                            
    5              0.000005     return 0

FUNCTION  <SNR>170_job_id()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim:104
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                              " Vim
    2              0.000029   return job_info(a:job).process

FUNCTION  <lambda>25()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   0.007469
 Self time:   0.000019

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:144
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
    1              0.000001     endif

FUNCTION  ale#c#GetMakeCommand()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:504
Called 1 time
Total time:   0.000068
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000047   0.000007     if s:CanParseMakefile(a:buffer)
                                    let l:path = ale#path#FindNearestFile(a:buffer, 'Makefile')
                            
                                    if empty(l:path)
                                        let l:path = ale#path#FindNearestFile(a:buffer, 'GNUmakefile')
                                    endif
                            
                                    if !empty(l:path)
                                        let l:always_make = ale#Var(a:buffer, 'c_always_make')
                            
                                        return [   fnamemodify(l:path, ':h'),   'make -n' . (l:always_make ? ' --always-make' : ''),]
                                    endif
    1              0.000000     endif
                            
    1              0.000001     return ['', '']

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/path.vim:37
Called 14 times
Total time:   0.067151
 Self time:   0.067151

count  total (s)   self (s)
   14              0.002672     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   14              0.000152     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   14              0.063575     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   14              0.000114     if !empty(l:relative_path)
    4              0.000516         return fnamemodify(l:relative_path, ':p')
   10              0.000013     endif
                            
   10              0.000014     return ''

FUNCTION  ale#c#RunMakeCommand()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:525
Called 1 time
Total time:   4.649148
 Self time:   0.002410

count  total (s)   self (s)
    1   0.000075   0.000007     let [l:cwd, l:command] = ale#c#GetMakeCommand(a:buffer)
                            
    1              0.000003     if empty(l:command)
    1   4.649068   0.002398         return a:Callback(a:buffer, [])
                                endif
                            
                                return ale#command#Run(   a:buffer,   l:command,   {b, output -> a:Callback(a:buffer, output)},   {'cwd': l:cwd},)

FUNCTION  <SNR>85_abs_path()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:222
Called 5 times
Total time:   0.002016
 Self time:   0.002016

count  total (s)   self (s)
    5              0.001897   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
    5              0.000091   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
    5              0.000016   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#Pad()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:202
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007     return !empty(a:string) ? ' ' . a:string : ''

FUNCTION  ale#util#Writefile()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:432
Called 1 time
Total time:   0.000764
 Self time:   0.000764

count  total (s)   self (s)
    1              0.000009     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
    1              0.000008     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
    1              0.000745     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:376
Called 1 time
Total time:   0.000328
 Self time:   0.000300

count  total (s)   self (s)
    1              0.000002     let l:command_list = []
    1              0.000002     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    1              0.000004     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    1   0.000024   0.000016         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    1              0.000001         let l:is_dummy_sign_set = 1
    1              0.000000     endif
                            
                                " Place new items first.
    4              0.000010     for [l:line_str, l:info] in items(a:sign_map)
    3              0.000006         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
    4              0.000005             for l:item in l:info.items
    2              0.000005                 let l:item.sign_id = l:info.new_id
    4              0.000004             endfor
                            
    2              0.000006             if index(l:info.current_id_list, l:info.new_id) < 0
    1   0.000115   0.000103                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    2              0.000002             endif
    3              0.000002         endif
    4              0.000005     endfor
                            
                                " Remove signs without new IDs.
    4              0.000006     for l:info in values(a:sign_map)
    5              0.000007         for l:current_id in l:info.current_id_list
    2              0.000003             if l:current_id isnot l:info.new_id
    1   0.000014   0.000010                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
    2              0.000002             endif
    5              0.000004         endfor
    4              0.000004     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    1              0.000002     if l:is_dummy_sign_set && !g:ale_sign_column_always
    1   0.000013   0.000009         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    1              0.000000     endif
                            
    1              0.000001     return l:command_list

FUNCTION  lightline#link()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:218
Called 11 times
Total time:   0.001713
 Self time:   0.001713

count  total (s)   self (s)
   11              0.000145   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
   11              0.000029   if s:mode ==# mode
    9              0.000013     return ''
    2              0.000002   endif
    2              0.000004   let s:mode = mode
    2              0.000006   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
    2              0.000001   endif
    2              0.000031   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    6              0.000022   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   20              0.000054     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   16              0.000024       if i != l
   12              0.000132         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   16              0.000011       endif
   80              0.000204       for [j, s] in map(range(0, l), '[v:val, 0]') + types
   64              0.000158         if i + 1 == j || t || s && i != l
   32              0.000410           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
   64              0.000041         endif
   80              0.000057       endfor
   20              0.000015     endfor
    6              0.000007   endfor
    2              0.000016   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    2              0.000002   return ''

FUNCTION  <SNR>154_ShouldOpen()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:41
Called 1 time
Total time:   0.000027
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000019   0.000006     let l:val = ale#Var(a:buffer, 'open_list')
    1              0.000004     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    1              0.000004     return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:239
Called 3 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
    3              0.000006     let l:msg = a:format_string
    3              0.000007     let l:severity = g:ale_echo_msg_warning_str
    3              0.000010     let l:code = get(a:item, 'code', '')
    3              0.000010     let l:type = get(a:item, 'type', 'E')
    3              0.000010     let l:linter_name = get(a:item, 'linter_name', '')
    3              0.000010     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    3              0.000006     if l:type is# 'E'
    1              0.000002         let l:severity = g:ale_echo_msg_error_str
    2              0.000003     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
    3              0.000001     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    3              0.000040     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
    3              0.000016     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    3              0.000015     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
    3              0.000020     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
    3              0.000012     let l:msg = substitute(l:msg, '\r', '', 'g')
                            
    3              0.000004     return l:msg

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:82
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000005     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
    1              0.000001     endif
                            
    1              0.000001     return 0

FUNCTION  ale_linters#c#cquery#GetProjectRoot()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/cquery.vim:7
Called 1 time
Total time:   0.021578
 Self time:   0.000263

count  total (s)   self (s)
                                " Try to find cquery configuration files first.
    1   0.006087   0.000241     let l:config = ale#path#FindNearestFile(a:buffer, '.cquery')
                            
    1              0.000003     if !empty(l:config)
                                    return fnamemodify(l:config, ':h')
    1              0.000001     endif
                            
                                " Fall back on default project root detection.
    1   0.015481   0.000012     return ale#c#FindProjectRoot(a:buffer)

FUNCTION  <SNR>152_FindHistoryItem()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/history.vim:36
Called 2 times
Total time:   0.000110
 Self time:   0.000094

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   14   0.000042   0.000026     for l:obj in reverse(ale#history#Get(a:buffer))
   14              0.000026         if l:obj.job_id == a:job_id
    2              0.000002             return l:obj
   12              0.000008         endif
   12              0.000008     endfor
                            
                                return {}

FUNCTION  ale#handlers#ccls#GetProjectRoot()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/ccls.vim:5
Called 1 time
Total time:   0.027147
 Self time:   0.000050

count  total (s)   self (s)
                                " Try to find ccls configuration files first.
    1   0.005857   0.000010     let l:config = ale#path#FindNearestFile(a:buffer, '.ccls-root')
                            
    1              0.000003     if empty(l:config)
    1   0.005625   0.000014         let l:config = ale#path#FindNearestFile(a:buffer, '.ccls')
    1              0.000001     endif
                            
    1              0.000003     if !empty(l:config)
                                    return fnamemodify(l:config, ':h')
    1              0.000001     endif
                            
                                " Fall back on default project root detection.
    1   0.015651   0.000012     return ale#c#FindProjectRoot(a:buffer)

FUNCTION  <SNR>149_FormatFilename()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:156
Called 1 time
Total time:   0.000038
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000002     let l:filename = a:filename
                            
    1              0.000002     if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
    1              0.000001     endif
                            
    1              0.000002     if !empty(a:modifiers)
    1              0.000004         let l:filename = fnamemodify(l:filename, a:modifiers)
    1              0.000001     endif
                            
    1   0.000021   0.000005     return ale#Escape(l:filename)

FUNCTION  <SNR>119_skip()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:30
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000010     return win_gettype() ==# 'popup' || win_gettype() ==# 'autocmd'

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:24
Called 5 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    5              0.000030     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    5              0.000020     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>148_RunIfExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:537
Called 4 times
Total time:   4.701566
 Self time:   0.000364

count  total (s)   self (s)
    4   0.000146   0.000121     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
    4              0.000004     endif
                            
    4   0.034528   0.000028     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    1              0.000003         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
    1              0.000004         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
    1   0.000015   0.000006         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
    1              0.000002         if l:cwd isnot v:null
                                        call ale#command#SetCwd(a:buffer, l:cwd)
    1              0.000001         endif
                            
    1   4.649177   0.000008         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
    1              0.000003         if l:cwd isnot v:null
                                        call ale#command#ResetCwd(a:buffer)
    1              0.000001         endif
                            
    1              0.000011         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
    1   0.017510   0.000011         return s:RunJob(l:command, l:options)
    3              0.000004     endif
                            
    3              0.000004     return 0

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:101
Called 3 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    3              0.000012     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    3              0.000020     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#c#FindProjectRoot()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:268
Called 4 times
Total time:   0.059708
 Self time:   0.000327

count  total (s)   self (s)
    4   0.045700   0.000043     let [l:root, l:json_file] = ale#c#FindCompileCommands(a:buffer)
                            
                                " Fall back on detecting the project root based on other filenames.
    4              0.000013     if empty(l:root)
    4              0.000013         for l:project_filename in g:__ale_c_project_filenames
    4   0.013875   0.000151             let l:full_path = ale#path#FindNearestFile(a:buffer, l:project_filename)
                            
    4              0.000016             if !empty(l:full_path)
    4              0.000018                 let l:path = fnamemodify(l:full_path, ':h')
                            
                                            " Correct .git path detection.
    4              0.000016                 if fnamemodify(l:path, ':t') is# '.git'
    4              0.000014                     let l:path = fnamemodify(l:path, ':h')
    4              0.000003                 endif
                            
    4              0.000008                 return l:path
                                        endif
                                    endfor
                                endif
                            
                                return l:root

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:39
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003     if has_key(s:buffer_data, a:buffer)
    1              0.000003         let s:buffer_data[a:buffer].cwd = v:null
    1              0.000001     endif

FUNCTION  <SNR>148_StopCurrentJobs()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:459
Called 1 time
Total time:   0.000119
 Self time:   0.000091

count  total (s)   self (s)
    1              0.000006     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1   0.000036   0.000008     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    1              0.000001     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
    1              0.000000     else
    1              0.000002         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
   10              0.000016         for [l:lint_file, l:linter] in a:linter_slots
    9              0.000012             if l:lint_file is 1
    2              0.000006                 let l:lint_file_map[l:linter.name] = 1
    9              0.000005             endif
   10              0.000006         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
    1              0.000004         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    1              0.000001     endif

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:192
Called 1 time
Total time:   0.001602
 Self time:   0.000294

count  total (s)   self (s)
    1              0.000002     let l:temporary_file = ''
    1              0.000001     let l:command = a:command
                            
    1              0.000002     if !empty(a:cwd)
                                    let l:command = ale#command#CdString(a:cwd) . l:command
    1              0.000000     endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    1              0.000006     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    1              0.000004     if !empty(a:executable) && l:command =~# '%e'
    1   0.000030   0.000011         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    1              0.000001     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    1              0.000003     if l:command =~# '%s'
    1              0.000167         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    1   0.000064   0.000026         let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
    1              0.000001     endif
                            
    1              0.000005     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
    1              0.000001     endif
                            
                                " Finish formatting so %% becomes %.
    1              0.000006     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    1              0.000003     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    1   0.000057   0.000008         let l:temporary_file = s:TemporaryFilename(a:buffer)
    1   0.000022   0.000008         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    1              0.000001     endif
                            
    1   0.001201   0.000013     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    1              0.000004     return [l:temporary_file, l:command, l:file_created]

FUNCTION  ale#job#ParseVim8ProcessID()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:140
Called 6 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    6              0.000044     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim_runtime/sources_non_forked/vim-fugitive/plugin/fugitive.vim:18
Called 32 times
Total time:   0.001806
 Self time:   0.001806

count  total (s)   self (s)
   32              0.000054   if v:version < 704
                                return ''
   32              0.000153   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
   32              0.000087     if exists('g:fugitive_event')
                                  return g:fugitive_event
   32              0.000022     endif
   32              0.000107     let dir = get(b:, 'git_dir', '')
   32              0.000135     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   32              0.000512     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(bufnr(''))
                                  return b:git_dir
   32              0.000025     endif
   32              0.000388     return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(a:1)
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'fugitive_dir', get(a:1, 'git_dir', ''))
                              else
                                return ''
                              endif

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000003   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    1              0.000000   endif

FUNCTION  ale#command#Run()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:333
Called 1 time
Total time:   0.014826
 Self time:   0.000226

count  total (s)   self (s)
    1              0.000007     let l:options = get(a:000, 0, {})
                            
    1              0.000002     if len(a:000) > 1
                                    throw 'Too many arguments!'
    1              0.000001     endif
                            
    1              0.000004     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    1              0.000002     let l:line_list = []
    1              0.000003     let l:cwd = get(l:options, 'cwd', v:null)
                            
    1              0.000002     if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
    1              0.000006         let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
    1              0.000001     endif
                            
    1   0.001621   0.000019     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
    1   0.000091   0.000010     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    1              0.000017     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    1              0.000002     if l:output_stream is# 'stdout'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
    1              0.000002     elseif l:output_stream is# 'stderr'
    1              0.000007         let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    1              0.000000     endif
                            
    1              0.000001     let l:status = 'failed'
                            
    1              0.000003     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
    1              0.000002     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
    1              0.000001     else
    1   0.012879   0.000009         let l:job_id = ale#job#Start(l:command, l:job_options)
    1              0.000001     endif
                            
    1              0.000001     if l:job_id
    1              0.000002         let l:status = 'started'
    1              0.000006         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    1   0.000017   0.000008         call ale#command#InitData(a:buffer)
    1              0.000005         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    1              0.000001     endif
                            
    1              0.000002     if g:ale_history_enabled
    1   0.000046   0.000008         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    1              0.000000     endif
                            
    1              0.000001     if !l:job_id
                                    return 0
    1              0.000000     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
    1              0.000009     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                            
    1              0.000004     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
    1              0.000001     endif
                            
    1              0.000002     return l:result

FUNCTION  <SNR>149_ExitCallback()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:285
Called 1 time
Total time:   0.007450
 Self time:   0.000177

count  total (s)   self (s)
    1              0.000003     if !has_key(s:buffer_data, a:buffer)
                                    return
    1              0.000001     endif
                            
    1              0.000003     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    1              0.000003     if !has_key(l:jobs, a:data.job_id)
                                    return
    1              0.000000     endif
                            
    1              0.000003     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    1              0.000001     if g:ale_history_enabled
    1   0.000080   0.000007         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    1              0.000002         if g:ale_history_log_output && a:data.log_output is 1
    1   0.000071   0.000009             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    1              0.000001         endif
    1              0.000001     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    1              0.000004     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    1   0.007207   0.000097     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    1              0.000002     let l:result = a:data.result
    1              0.000003     let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
    1   0.000028   0.000007     call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
    1              0.000001     try
    1              0.000004         if get(l:result, 'result_callback', v:null) isnot v:null
                                        call call(l:result.result_callback, [l:value])
    1              0.000001         endif
    1              0.000001     finally
    1   0.000013   0.000006         call ale#command#ResetCwd(a:buffer)
    1              0.000001     endtry

FUNCTION  <SNR>85_unc_path()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:186
Called 1 time
Total time:   0.000386
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000386   0.000009   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  ale#c#GetLanguageFlag()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:591
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                                " Use only '-header' if the executable is 'clang' by default
    1              0.000002     if a:use_header_lang_flag == -1
    1              0.000007         let l:use_header_lang_flag = a:executable =~# 'clang'
                                else
                                    let l:use_header_lang_flag = a:use_header_lang_flag
    1              0.000001     endif
                            
                                " If we don't use the header language flag, return the default linter
                                " language flag
    1              0.000002     if !l:use_header_lang_flag
    1              0.000002         return a:linter_lang_flag
                                endif
                            
                                " Get the buffer file extension
                                let l:buf_ext = expand('#' . a:buffer . ':e')
                            
                                " If the buffer file is an header according to its extension, use
                                " the linter language flag + '-header', ex: 'c-header'
                                if index(a:header_exts, l:buf_ext) >= 0
                                    return a:linter_lang_flag . '-header'
                                endif
                            
                                " Else, use the default linter language flag
                                return a:linter_lang_flag

FUNCTION  ale#util#LocItemCompareWithText()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:209
Called 3 times
Total time:   0.000094
 Self time:   0.000030

count  total (s)   self (s)
    3   0.000085   0.000021     let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                            
    3              0.000003     if l:cmp_value
    3              0.000005         return l:cmp_value
                                endif
                            
                                if a:left.text < a:right.text
                                    return -1
                                endif
                            
                                if a:left.text > a:right.text
                                    return 1
                                endif
                            
                                return 0

FUNCTION  ale#c#FindCompileCommands()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:239
Called 5 times
Total time:   4.666324
 Self time:   4.639300

count  total (s)   self (s)
                                " Look above the current source file to find compile_commands.json
    5   0.025722   0.000050     let l:json_file = ale#path#FindNearestFile(a:buffer, 'compile_commands.json')
                            
    5              0.000012     if !empty(l:json_file)
                                    return [fnamemodify(l:json_file, ':h'), l:json_file]
    5              0.000003     endif
                            
                                " Search in build directories if we can't find it in the project.
   40   0.001950   0.001178     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
  105   0.001113   0.000533         for l:dirname in ale#Var(a:buffer, 'c_build_dir_names')
   70              0.000249             let l:c_build_dir = l:path . s:sep . l:dirname
   70              0.000240             let l:json_file = l:c_build_dir . s:sep . 'compile_commands.json'
                            
   70              4.636098             if filereadable(l:json_file)
                                            return [l:path, l:json_file]
   70              0.000068             endif
  105              0.000091         endfor
   40              0.000033     endfor
                            
    5              0.000010     return ['', '']

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:471
Called 26 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   26              0.000103     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  ale#handlers#gcc#HandleGCCFormatWithIncludes()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/gcc.vim:169
Called 1 time
Total time:   0.001041
 Self time:   0.000114

count  total (s)   self (s)
    1   0.000625   0.000011     let l:output = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
                            
    1   0.000159   0.000014     call extend(l:output, s:ParseInlinedFunctionProblems(a:buffer, a:lines))
    1   0.000255   0.000087     call extend(l:output, s:ParseProblemsInHeaders(a:buffer, a:lines))
                            
    1              0.000001     return l:output

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:175
Called 1 time
Total time:   0.000081
 Self time:   0.000065

count  total (s)   self (s)
    1   0.000021   0.000005     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    1              0.000006     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    1              0.000003     if exists('b:ale_shell')
                                    let l:ale_shell = b:ale_shell
    1              0.000003     elseif exists('g:ale_shell')
                                    let l:ale_shell = g:ale_shell
    1              0.000001     endif
                            
    1              0.000002     if exists('l:ale_shell')
                                    let l:shell_arguments = get(b:, 'ale_shell_arguments', get(g:, 'ale_shell_arguments', &shellcmdflag))
                            
                                    return split(l:ale_shell) + split(l:shell_arguments) + [l:command]
    1              0.000001     endif
                            
    1              0.000003     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
    1              0.000001     endif
                            
    1              0.000006     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
    1              0.000001     endif
                            
    1              0.000013     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:53
Called 9 times
Total time:   0.092135
 Self time:   0.091731

count  total (s)   self (s)
    9              0.000024     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
    9              0.000005     endif
                            
                                " Check for a cached executable() check.
    9              0.000045     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    9              0.000016     if l:result isnot v:null
    1              0.000002         return l:result
    8              0.000005     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    8              0.091243     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    8              0.000083     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
    8              0.000008     endif
                            
    8              0.000016     if g:ale_history_enabled
    8   0.000536   0.000132         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    8              0.000007     endif
                            
    8              0.000011     return l:result

FUNCTION  ale#Escape()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:219
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000012     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
    3              0.000002     endif
                            
    3              0.000012     return shellescape (a:str)

FUNCTION  lightline#statusline()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:309
Called 4 times
Total time:   0.004428
 Self time:   0.000077

count  total (s)   self (s)
    4              0.000015   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
    4              0.000004   endif
    4   0.004398   0.000047   return s:line(0, a:inactive)

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:181
Called 1 time
Total time:   0.000805
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000411   0.000017   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    1   0.000393   0.000008   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:326
Called 1 time
Total time:   0.000067
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000061   0.000010     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    1              0.000003     if type(l:filetype) isnot v:t_list
    1              0.000002         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>153_GroupCmd()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:162
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000006     if s:supports_sign_groups
    4              0.000004         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <SNR>148_HandleExit()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:151
Called 1 time
Total time:   0.007110
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000007     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    1              0.000002     if empty(l:buffer_info)
                                    return
    1              0.000001     endif
                            
    1              0.000002     let l:linter = a:job_info.linter
    1              0.000003     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    1   0.000016   0.000008     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000019   0.000004     if ale#util#InSandbox()
                                    return
    1              0.000001     endif
                            
    1              0.000008     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    1              0.000001     endif
                            
    1              0.000001     try
    1   0.001062   0.000014         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    1              0.000001     endtry
                            
    1   0.005975   0.000009     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:232
Called 3 times
Total time:   0.000355
 Self time:   0.000355

count  total (s)   self (s)
    3              0.000005     let l:min = 0
    3              0.000009     let l:max = len(a:loclist) - 1
                            
    8              0.000010     while 1
    8              0.000015         if l:max < l:min
    2              0.000002             return -1
    6              0.000006         endif
                            
    6              0.000015         let l:mid = (l:min + l:max) / 2
    6              0.000017         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    6              0.000009         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
    6              0.000009         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
    6              0.000007         elseif l:item.lnum < a:line
    3              0.000004             let l:min = l:mid + 1
    3              0.000003         elseif l:item.lnum > a:line
    2              0.000004             let l:max = l:mid - 1
    1              0.000000         else
                                        " This part is a small sequential search.
    1              0.000002             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    1              0.000006             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
    1              0.000001             endwhile
                            
                                        " Find the last problem on or before this column.
    1              0.000005             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
    1              0.000001             endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    1              0.000003             let l:item_column = a:loclist[l:index].col
                            
    1              0.000005             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
    1              0.000001             endwhile
                            
    1              0.000001             return l:index
    5              0.000003         endif
    5              0.000003     endwhile

FUNCTION  FugitiveHead()
    Defined: ~/.vim_runtime/sources_non_forked/vim-fugitive/plugin/fugitive.vim:236
Called 16 times
Total time:   0.007635
 Self time:   0.000611

count  total (s)   self (s)
   16              0.000096   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
   16              0.000022   elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
   16              0.000014   else
   16   0.001026   0.000089     let dir = FugitiveGitDir()
   16              0.000059     let arg = get(a:, 1, 0)
   16              0.000011   endif
   16              0.000032   if empty(dir)
                                return ''
   16              0.000010   endif
   16   0.006201   0.000114   return fugitive#Head(arg, dir)

FUNCTION  <SNR>149_TemporaryFilename()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:132
Called 1 time
Total time:   0.000049
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000005     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    1              0.000002     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
    1              0.000000     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    1   0.000034   0.000009     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>170_on_stderr_vim()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim:83
Called 2 times
Total time:   0.000114
 Self time:   0.000032

count  total (s)   self (s)
    2   0.000111   0.000029   call self.handler.err(self.buffer)

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:269
Called 2 times
Total time:   0.000076
 Self time:   0.000049

count  total (s)   self (s)
    2   0.000040   0.000013     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
    2              0.000006     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
    2              0.000000     endif
                            
    2              0.000004     let l:name = a:name
                            
    2              0.000006     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
    2              0.000003         let l:name = '*'
    2              0.000001     endif
                            
    2              0.000006     return get(l:linter_mappings, l:name, [])

FUNCTION  ale#Var()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:180
Called 65 times
Total time:   0.001057
 Self time:   0.001057

count  total (s)   self (s)
   65              0.000199     let l:full_name = 'ale_' . a:variable_name
   65              0.000471     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   65              0.000291     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:72
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000029   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    3              0.000006     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:445
Called 1 time
Total time:   4.649169
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003     let l:Command = a:linter.command
                            
    1   4.649165   0.000008     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  <SNR>167_VimCloseCallback()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:88
Called 1 time
Total time:   0.007695
 Self time:   0.000146

count  total (s)   self (s)
    1              0.000003     let l:job = ch_getjob(a:channel)
    1   0.000015   0.000008     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
    1              0.000004     let l:info = get(s:job_map, l:job_id, {})
                            
    1              0.000002     if empty(l:info)
                                    return
    1              0.000000     endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
    1   0.007646   0.000104     if job_status(l:job) is# 'dead'
    1              0.000001         try
    1              0.000004             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
    1              0.000001             endif
    1              0.000001         finally
                                        " Automatically forget about the job after it's done.
    1              0.000002             if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
    1              0.000000             endif
    1              0.000000         endtry
    1              0.000001     endif

FUNCTION  lightline#mode()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:213
Called 8 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    8              0.000041   return get(s:lightline.mode_map, mode(), '')

FUNCTION  ale#c#GetCFlags()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:482
Called 1 time
Total time:   4.635693
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000002     let l:cflags = v:null
                            
    1   0.000020   0.000005     if ale#Var(a:buffer, 'c_parse_compile_commands')
    1   4.620679   0.000012         let [l:root, l:json_file] = ale#c#FindCompileCommands(a:buffer)
                            
    1              0.000004         if !empty(l:json_file)
                                        let l:cflags = ale#c#FlagsFromCompileCommands(a:buffer, l:json_file)
    1              0.000001         endif
    1              0.000001     endif
                            
    1   0.000392   0.000017     if empty(l:cflags) && s:CanParseMakefile(a:buffer) && !empty(a:output)
                                    let l:cflags = ale#c#ParseCFlagsFromMakeOutput(a:buffer, a:output)
    1              0.000001     endif
                            
    1              0.000003     if l:cflags is v:null
    1   0.014575   0.000016         let l:cflags = ale#c#IncludeOptions(ale#c#FindLocalHeaderPaths(a:buffer))
    1              0.000001     endif
                            
    1              0.000004     return l:cflags isnot v:null ? l:cflags : ''

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return s:available

FUNCTION  <SNR>85_not_git_dir()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:58
Called 1 time
Total time:   0.000451
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000451   0.000014   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>154_FixList()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:76
Called 1 time
Total time:   0.000239
 Self time:   0.000078

count  total (s)   self (s)
    1   0.000026   0.000008     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000002     let l:new_list = []
                            
    3              0.000005     for l:item in a:list
    2              0.000010         let l:fixed_item = copy(l:item)
                            
    2   0.000158   0.000015         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    2              0.000003         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
    2              0.000002         endif
                            
    2              0.000007         call add(l:new_list, l:fixed_item)
    3              0.000003     endfor
                            
    1              0.000001     return l:new_list

FUNCTION  <SNR>153_BuildSignMap()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:307
Called 1 time
Total time:   0.000316
 Self time:   0.000205

count  total (s)   self (s)
    1   0.000019   0.000005     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    1              0.000001     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    1              0.000003     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    1              0.000001     else
    1              0.000002         let l:selected_grouped_items = a:grouped_items
    1              0.000001     endif
                            
    1              0.000001     let l:sign_map = {}
    1              0.000002     let l:sign_offset = g:ale_sign_offset
                            
    3              0.000006     for [l:line, l:sign_id, l:name] in a:current_sign_list
    2              0.000017         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    2              0.000003         if l:sign_id > l:sign_offset
    2              0.000004             let l:sign_offset = l:sign_id
    2              0.000002         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    2              0.000006         call add(l:sign_info.current_id_list, l:sign_id)
    2              0.000006         call add(l:sign_info.current_name_list, l:name)
                            
    2              0.000006         let l:sign_map[l:line] = l:sign_info
    3              0.000003     endfor
                            
    3              0.000004     for l:group in l:selected_grouped_items
    2              0.000005         let l:line = l:group[0].lnum
    2              0.000016         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
    2   0.000110   0.000013         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
    2              0.000003         let l:sign_info.items = l:group
                            
    2              0.000007         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
    2              0.000003         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
    1              0.000003             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    1              0.000000         else
                                        " This sign name replaces the previous name, so use a new ID.
    1              0.000002             let l:sign_info.new_id = l:sign_offset + 1
    1              0.000002             let l:sign_offset += 1
    2              0.000002         endif
                            
    2              0.000006         let l:sign_map[l:line] = l:sign_info
    3              0.000004     endfor
                            
    1              0.000002     return l:sign_map

FUNCTION  <SNR>154_CloseWindowIfNeeded()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:242
Called 1 time
Total time:   0.000049
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000047   0.000009     if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
    1              0.000001         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim_runtime/sources_non_forked/vim-fugitive/autoload/fugitive.vim:1016
Called 16 times
Total time:   0.006087
 Self time:   0.004832

count  total (s)   self (s)
   16              0.000059   let dir = a:0 > 1 ? a:2 : s:Dir()
   16              0.000030   if empty(dir)
                                return ''
   16              0.000008   endif
   16   0.001619   0.000364   let file = FugitiveActualDir() . '/HEAD'
   16              0.003345   let ftime = getftime(file)
   16              0.000054   if ftime == -1
                                return ''
   16              0.000113   elseif ftime != get(s:head_cache, file, [-1])[0]
                                let s:head_cache[file] = [ftime, readfile(file)[0]]
   16              0.000011   endif
   16              0.000052   let head = s:head_cache[file][1]
   16              0.000034   let len = a:0 ? a:1 : 0
   16              0.000177   if head =~# '^ref: '
   16              0.000023     if len < 0
                                  return strpart(head, 5)
   16              0.000012     else
   16              0.000372       return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                                endif
                              elseif head =~# '^\x\{40,\}$'
                                return len < 0 ? head : strpart(head, 0, len)
                              else
                                return ''
                              endif

FUNCTION  ale#cursor#Echom()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/cursor.vim:14
Called 1 time
Total time:   0.001405
 Self time:   0.001405

count  total (s)   self (s)
                                " no-custom-checks
    1              0.001404     exec "norm! :echom a:message\n"

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:263
Called 1 time
Total time:   0.000477
 Self time:   0.000413

count  total (s)   self (s)
    1   0.000046   0.000008     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    1              0.000003     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    1              0.000001     endif
                            
    1              0.000002     let l:bufnr_map = {}
    1              0.000002     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    1   0.000018   0.000006     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    3              0.000004     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    2              0.000031         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    2              0.000004         if a:from_other_source
                                        let l:item.from_other_source = 1
    2              0.000002         endif
                            
    2              0.000005         if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
    2              0.000001         endif
                            
    2              0.000006         let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
    2              0.000006         if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
    2              0.000002         endif
                            
    2              0.000006         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
    2              0.000004         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
    2              0.000002         endif
                            
    2              0.000004         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
    2              0.000001         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    2              0.000004         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
    2              0.000002         endif
                            
    2              0.000006         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                            
                                        " When the error ends after the end of the file, put it at the
                                        " end. This is only done for the current buffer.
                                        if l:item.bufnr == a:buffer && l:item.end_lnum > l:last_line_number
                                            let l:item.end_lnum = l:last_line_number
                                        endif
    2              0.000002         endif
                            
    2              0.000005         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
    2              0.000001         endif
                            
    2              0.000003         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
    2              0.000006         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
    2              0.000005         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
    2              0.000001         endif
                            
    2              0.000005         call add(l:new_loclist, l:item)
    3              0.000009     endfor
                            
    1   0.000022   0.000008     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    1              0.000003     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    1              0.000000     endif
                            
    1              0.000001     return l:new_loclist

FUNCTION  <SNR>123_setup_path()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter.vim:169
Called 1 time
Total time:   0.014753
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000046   0.000009   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    1   0.014705   0.000009   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:129
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000003     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
    2              0.000002     endif
                            
    2              0.000004     if a:item.type is# 'W'
    2              0.000006         if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
    2              0.000001         endif
                            
    2              0.000002         return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority

FUNCTION  ale#cursor#TruncatedEcho()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/cursor.vim:19
Called 1 time
Total time:   0.001490
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000002     let l:message = a:original_message
                                " Change tabs to spaces.
    1              0.000005     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    1              0.000004     let l:message = substitute(l:message, "\n", '', 'g')
                                " Convert indentation groups into single spaces for better legibility when
                                " put on a single line
    1              0.000008     let l:message = substitute(l:message, ' \+', ' ', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    1              0.000002     let l:shortmess_options = &l:shortmess
                            
    1              0.000001     try
    1              0.000003         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    1              0.000007         silent! setlocal shortmess+=T
                            
    1              0.000001         try
    1   0.001413   0.000008             call ale#cursor#Echom(l:message)
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
    1              0.000001         endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    1              0.000005         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
    1              0.000001         endif
    1              0.000001     finally
    1              0.000005         let &l:shortmess = l:shortmess_options
    1              0.000001     endtry

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 3 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    3              0.000012   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
    3              0.000022   let ggvars = getbufvar(buffer, 'gitgutter')
    3              0.000012   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
    3              0.000002   endif
    3              0.000008   let ggvars[a:varname] = a:val

FUNCTION  ale_linters#c#cc#GetExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/cc.vim:9
Called 2 times
Total time:   0.022087
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000041   0.000013     let l:executable = ale#Var(a:buffer, 'c_cc_executable')
                            
                                " Default to either clang or gcc.
    2              0.000003     if l:executable is# '<auto>'
    2   0.022023   0.000014         if ale#engine#IsExecutable(a:buffer, 'clang')
                                        let l:executable = 'clang'
    2              0.000002         else
    2              0.000004             let l:executable = 'gcc'
    2              0.000001         endif
    2              0.000002     endif
                            
    2              0.000003     return l:executable

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:689
Called 1 time
Total time:   4.825288
 Self time:   0.000138

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    1   0.000117   0.000102     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    1   4.825169   0.000034     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  ale#c#IncludeOptions()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:575
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002     let l:option_list = []
                            
    1              0.000002     for l:path in a:include_paths
                                    call add(l:option_list, '-I' . ale#Escape(l:path))
    1              0.000001     endfor
                            
    1              0.000002     if empty(l:option_list)
    1              0.000001         return ''
                                endif
                            
                                return join(l:option_list)

FUNCTION  ale#history#Add()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/history.vim:12
Called 9 times
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
    9              0.000023     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
    9              0.000007     endif
                            
    9              0.000077     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    9              0.000028     if len(l:history) >= g:ale_max_buffer_history_size
    8              0.000073         let l:history = l:history[1:]
    9              0.000008     endif
                            
    9              0.000072     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    9              0.000066     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>148_RunJob()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:411
Called 1 time
Total time:   0.017499
 Self time:   0.000215

count  total (s)   self (s)
    1   0.000012   0.000006     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    1              0.000001     endif
                            
    1              0.000002     let l:command = a:command
                            
    1              0.000002     if empty(l:command)
                                    return 0
    1              0.000001     endif
                            
    1              0.000001     let l:cwd = a:options.cwd
    1              0.000002     let l:executable = a:options.executable
    1              0.000002     let l:buffer = a:options.buffer
    1              0.000002     let l:linter = a:options.linter
    1              0.000002     let l:output_stream = a:options.output_stream
    1              0.000003     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
    1              0.000003     let l:info = g:ale_buffer_info[l:buffer]
                            
    1              0.000010     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
    1   0.015001   0.000137     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
    1              0.000002     if empty(l:result)
                                    return 0
    1              0.000000     endif
                            
    1   0.000027   0.000009     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    1   0.002407   0.000011     silent doautocmd <nomodeline> User ALEJobStarted
                            
    1              0.000002     return 1

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:460
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000007     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    1              0.000005     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    1              0.000002     return l:timer_id

FUNCTION  <SNR>153_UpdateLineNumbers()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:282
Called 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000002     let l:line_map = {}
    1              0.000002     let l:line_numbers_changed = 0
                            
    3              0.000007     for [l:line, l:sign_id, l:name] in a:current_sign_list
    2              0.000006         let l:line_map[l:sign_id] = l:line
    3              0.000003     endfor
                            
    3              0.000004     for l:item in a:loclist
    2              0.000004         if l:item.bufnr == a:buffer
    2              0.000009             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
    2              0.000004             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
    2              0.000002             endif
    2              0.000001         endif
    3              0.000002     endfor
                            
                                " When the line numbers change, sort the list again
    1              0.000001     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    1              0.000000     endif

FUNCTION  ale#command#InitData()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:22
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000012     if !has_key(s:buffer_data, a:buffer)
    1              0.000006         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    3              0.000003     endif

FUNCTION  ale#util#LocItemCompare()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:151
Called 5 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    5              0.000010     if a:left.bufnr < a:right.bufnr
                                    return -1
    5              0.000003     endif
                            
    5              0.000008     if a:left.bufnr > a:right.bufnr
                                    return 1
    5              0.000002     endif
                            
    5              0.000006     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
    5              0.000003     endif
                            
    5              0.000008     if a:left.lnum < a:right.lnum
    5              0.000005         return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 1 time
Total time:   0.000027
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000023   0.000008   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
    1              0.000003   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/history.vim:49
Called 1 time
Total time:   0.000073
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000066   0.000007     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    1              0.000003     let l:obj.exit_code = a:exit_code
    1              0.000002     let l:obj.status = 'finished'

FUNCTION  <SNR>169_ParseProblemsInHeaders()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/gcc.vim:52
Called 1 time
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
    1              0.000004     let l:output = []
    1              0.000002     let l:include_item = {}
                            
    3              0.000008     for l:line in a:lines[: -2]
    2              0.000013         let l:include_match = matchlist(l:line, '\v^In file included from')
                            
    2              0.000005         if !empty(l:include_item)
                                        let l:pattern_match = matchlist(l:line, s:pattern)
                            
                                        if !empty(l:pattern_match) && l:pattern_match[1] is# '<stdin>'
                                            if has_key(l:include_item, 'lnum')
                                                call add(l:output, l:include_item)
                                            endif
                            
                                            let l:include_item = {}
                            
                                            continue
                                        endif
                            
                                        let l:include_item.detail .= "\n" . l:line
    2              0.000002         endif
                            
    2              0.000006         if !empty(l:include_match)
                                        if empty(l:include_item)
                                            let l:include_item = {   'text': 'Error found in header. See :ALEDetail',   'detail': l:line,}
                                        endif
    2              0.000002         endif
                            
    2              0.000004         if !empty(l:include_item)
                                        let l:stdin_match = matchlist(l:line, '\vfrom \<stdin\>:(\d+):(\d*):?$')
                            
                                        if !empty(l:stdin_match)
                                            let l:include_item.lnum = str2nr(l:stdin_match[1])
                            
                                            if str2nr(l:stdin_match[2])
                                                let l:include_item.col = str2nr(l:stdin_match[2])
                                            endif
                                        endif
    2              0.000000         endif
    3              0.000004     endfor
                            
    1              0.000003     if !empty(l:include_item) && has_key(l:include_item, 'lnum')
                                    call add(l:output, l:include_item)
    1              0.000001     endif
                            
    1              0.000001     return l:output

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:50
Called 1 time
Total time:   0.000022
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000016   0.000006     call ale#command#InitData(a:buffer)
    1              0.000005     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:253
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008   return has('win64') || has('win32') || has('win16')

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:108
Called 1 time
Total time:   0.005966
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000004     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    1              0.000002     if empty(l:info)
                                    return
    1              0.000001     endif
                            
    1              0.000001     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    1              0.000003         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    1              0.000000     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    1   0.000488   0.000011     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    1              0.000010     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    1              0.000002     if !empty(l:linter_loclist)
                                    " Add the new items.
    1              0.000003         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    1   0.000054   0.000012         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    1              0.000001     endif
                            
    1   0.000124   0.000006     if ale#ShouldDoNothing(a:buffer)
                                    return
    1              0.000001     endif
                            
    1   0.005257   0.000007     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:277
Called 1 time
Total time:   0.000054
 Self time:   0.000045

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    1   0.000014   0.000005     if ale#util#InSandbox()
                                    return []
    1              0.000001     endif
                            
    1              0.000001     let l:combined_linters = []
                            
    2              0.000003     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    1              0.000003         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
    1              0.000001         endif
                            
    1              0.000008         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    2              0.000002     endfor
                            
    1              0.000002     return l:combined_linters

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:485
Called 3 times
Total time:   0.000455
 Self time:   0.000100

count  total (s)   self (s)
    3              0.000024     let l:info = get(g:ale_buffer_info, a:buffer, {})
    3              0.000011     let l:loclist = get(l:info, 'loclist', [])
    3              0.000010     let l:pos = getpos('.')
    3   0.000388   0.000033     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    3              0.000011     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    3              0.000006     return [l:info, l:loc]

FUNCTION  <SNR>150_StartIfExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/lsp_linter.vim:409
Called 3 times
Total time:   0.035826
 Self time:   0.000184

count  total (s)   self (s)
    3   0.000038   0.000022     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
    3              0.000002     endif
                            
    3   0.035759   0.000133     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
    3              0.000003         return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:43
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  ale#util#Mode()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:5
Called 5 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    5              0.000018     return call('mode', a:000)

FUNCTION  <SNR>119_line()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:386
Called 4 times
Total time:   0.004351
 Self time:   0.001970

count  total (s)   self (s)
    4              0.000010   let _ = a:tabline ? '' : '%{lightline#link()}'
    4              0.000011   if s:lightline.palette == {}
                                call lightline#colorscheme()
    4              0.000001   endif
    4              0.000020   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
    4              0.000025   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
    4              0.000019   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
    4              0.000012   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
    4              0.000021   let ls = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
    4   0.001014   0.000041   let [lc, le, li] = s:expand(ls)
    4              0.000022   let rs = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
    4   0.000895   0.000038   let [rc, re, ri] = s:expand(rs)
   10              0.000020   for i in range(len(lc))
    6              0.000031     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
   20              0.000035     for j in range(len(lc[i]))
   14              0.000144       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
   14              0.000157       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   14              0.000050       if j < len(lc[i]) - 1 && s.left !=# ''
    8   0.000658   0.000107         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
   14              0.000012       endif
   20              0.000013     endfor
    6              0.000038     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
    6              0.000051     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
   10              0.000012   endfor
    4              0.000012   let _ .= '%#LightlineMiddle_' . mode . '#%='
   12              0.000021   for i in range(len(rc) - 1, 0, -1)
    8              0.000050     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
    8              0.000068     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
    8              0.000036     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
   16              0.000035     for j in range(len(rc[i]))
    8              0.000081       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
    8              0.000089       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
    8              0.000027       if j < len(rc[i]) - 1 && s.right !=# ''
                                    let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
    8              0.000006       endif
   16              0.000010     endfor
   12              0.000012   endfor
    4              0.000006   return _

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/list.vim:207
Called 1 time
Total time:   0.000041
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000006     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    1              0.000001     else
    1   0.000026   0.000012         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    1              0.000001     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:290
Called 8 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    8              0.000007     try
    8              0.000041         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
    8              0.000008     endtry
                            
    8              0.000008     return 0

FUNCTION  <SNR>148_GetLintFileSlots()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:601
Called 1 time
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000002     let l:linter_slots = []
                            
   10              0.000012     for l:linter in a:linters
    9              0.000016         let l:LintFile = l:linter.lint_file
                            
    9              0.000024         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
    9              0.000007         endif
                            
    9              0.000030         call add(l:linter_slots, [l:LintFile, l:linter])
   10              0.000006     endfor
                            
    1              0.000001     return l:linter_slots

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/path.vim:15
Called 5 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    5              0.000011     if has('unix')
    5              0.000040         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
    5              0.000045         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>85_is_file_buffer()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:62
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  ale#path#Upwards()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/path.vim:195
Called 5 times
Total time:   0.000772
 Self time:   0.000665

count  total (s)   self (s)
    5              0.000043     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
    5              0.000018     let l:sep = has('win32') ? '\' : '/'
    5   0.000183   0.000076     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
    5              0.000010     let l:path_list = []
                            
   35              0.000074     while !empty(l:parts)
   30              0.000141         call add(l:path_list, join(l:parts, l:sep))
   30              0.000102         let l:parts = l:parts[:-2]
   35              0.000031     endwhile
                            
    5              0.000016     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
    5              0.000015     elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
    5              0.000050         call map(l:path_list, '''/'' . v:val')
    5              0.000013         call add(l:path_list, '/')
    5              0.000005     endif
                            
    5              0.000007     return l:path_list

FUNCTION  ale#sign#ParseSignsWithGetPlaced()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/sign.vim:205
Called 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000014     let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale' : '' })[0].signs
    1              0.000002     let l:result = []
    1              0.000002     let l:is_dummy_sign_set = 0
                            
    3              0.000005     for l:sign in l:signs
    2              0.000005         if l:sign['name'] is# 'ALEDummySign'
                                        let l:is_dummy_sign_set = 1
    2              0.000002         else
    2              0.000015             call add(l:result, [   str2nr(l:sign['lnum']),   str2nr(l:sign['id']),   l:sign['name'],])
    2              0.000002         endif
    3              0.000004     endfor
                            
    1              0.000002     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/lsp_linter.vim:223
Called 3 times
Total time:   0.063620
 Self time:   0.000218

count  total (s)   self (s)
    3              0.000026     let l:buffer_ale_root = getbufvar(   a:buffer,   'ale_root',   getbufvar(a:buffer, 'ale_lsp_root', {}))
                            
    3              0.000013     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
    3              0.000002     endif
                            
                                " Try to get a buffer-local setting for the root
    3              0.000011     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    3              0.000003     endif
                            
    3              0.000008     let l:global_root = g:ale_root
                            
    3              0.000012     if empty(g:ale_root) && exists('g:ale_lsp_root')
                                    let l:global_root = g:ale_lsp_root
    3              0.000001     endif
                            
                                " Try to get a global setting for the root
    3              0.000009     if has_key(l:global_root, a:linter.name)
                                    let l:Root = l:global_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    3              0.000002     endif
                            
                                " Fall back to the linter-specific configuration
    3              0.000007     if has_key(a:linter, 'project_root')
    3              0.000011         let l:Root = a:linter.project_root
                            
    3   0.063437   0.000035         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:84
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000011     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  <SNR>170_on_exit_vim()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim:87
Called 1 time
Total time:   0.000063
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000008   let job = ch_getjob(a:channel)
    1   0.000021   0.000009   let jobid = s:job_id(job)
    1              0.000009   if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
    1              0.000002   while 1
    1              0.000004     if job_status(job) == 'dead'
    1              0.000006       let exit_code = job_info(job).exitval
    1              0.000001       break
                                endif
                                sleep 5m
    1              0.000002   endwhile
                            
    1              0.000002   if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    1              0.000001   endif

FUNCTION  <SNR>170_build_command()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   if has('unix')
    1              0.000002     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 1 time
Total time:   0.013297
 Self time:   0.013227

count  total (s)   self (s)
    1   0.000148   0.000104   call gitgutter#debug#log('[async] '.a:cmd)
                            
    1              0.000006   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    1   0.000014   0.000008   let command = s:build_command(a:cmd)
                            
    1              0.000004   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    1              0.000000   else
    1              0.013059     let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    1   0.000052   0.000032     let s:jobs[s:job_id(job)] = 1
    1              0.000002   endif

FUNCTION  ale#util#GetMatches()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:325
Called 1 time
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
    1              0.000002     let l:matches = []
    1              0.000004     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
    1              0.000004     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
    4              0.000005     for l:line in l:lines
    4              0.000007         for l:pattern in l:patterns
    3              0.000134             let l:match = matchlist(l:line, l:pattern)
                            
    3              0.000007             if !empty(l:match)
    2              0.000005                 call add(l:matches, l:match)
    2              0.000002                 break
    1              0.000000             endif
    4              0.000004         endfor
    4              0.000005     endfor
                            
    1              0.000002     return l:matches

FUNCTION  <SNR>149_GatherOutput()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:281
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000013     call add(a:line_list, a:line)

FUNCTION  ale#path#FindNearestExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/path.vim:82
Called 1 time
Total time:   0.010568
 Self time:   0.000086

count  total (s)   self (s)
    3              0.000008     for l:path in a:path_list
    2   0.000047   0.000016         if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
    2              0.000002         else
    2   0.010473   0.000022             let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
    2              0.000002         endif
                            
    2              0.000004         if !empty(l:executable)
                                        return l:executable
    2              0.000001         endif
    3              0.000003     endfor
                            
    1              0.000001     return ''

FUNCTION  <SNR>167_VimExitCallback()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:114
Called 1 time
Total time:   0.007542
 Self time:   0.000058

count  total (s)   self (s)
    1   0.000018   0.000011     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
    1              0.000004     let l:info = get(s:job_map, l:job_id, {})
                            
    1              0.000002     if empty(l:info)
                                    return
    1              0.000001     endif
                            
    1              0.000003     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
    1              0.000004     if ch_status(job_getchannel(a:job)) is# 'closed'
    1              0.000000         try
    1              0.000003             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
    1   0.007489   0.000012                 call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
    1              0.000001             endif
    1              0.000001         finally
                                        " Automatically forget about the job after it's done.
    1              0.000003             if has_key(s:job_map, l:job_id)
    1              0.000003                 call remove(s:job_map, l:job_id)
    1              0.000001             endif
    1              0.000001         endtry
    1              0.000001     endif

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:110
Called 1 time
Total time:   0.001188
 Self time:   0.000402

count  total (s)   self (s)
    1              0.000003     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
    1              0.000000     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    1              0.000010     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    1              0.000004     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    1              0.000354     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    1   0.000034   0.000012     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    1   0.000772   0.000008     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    1              0.000003     return 1

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/cursor.vim:72
Called 3 times
Total time:   0.003236
 Self time:   0.000834

count  total (s)   self (s)
    3              0.000008     let l:buffer = bufnr('')
                            
    3              0.000007     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    3              0.000002     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    3              0.000009     if mode(1) isnot# 'n'
                                    return
    3              0.000002     endif
                            
    3   0.000389   0.000018     if ale#ShouldDoNothing(l:buffer)
                                    return
    3              0.000001     endif
                            
    3   0.000824   0.000369     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    3              0.000123     if g:ale_echo_cursor
    3              0.000007         if !empty(l:loc)
    1   0.000021   0.000006             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    1   0.000079   0.000008             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    1   0.001498   0.000008             call ale#cursor#TruncatedEcho(l:msg)
    1              0.000002             let l:info.echoed = 1
    2              0.000004         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        "
                                        " no-custom-checks
    1              0.000158             echo
    1              0.000004             let l:info.echoed = 0
    3              0.000002         endif
    3              0.000003     endif
                            
    3              0.000005     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    3              0.000003     endif

FUNCTION  <SNR>143_ApplyPartialTimer()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:447
Called 1 time
Total time:   0.000914
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000007     if has_key(s:partial_timers, a:timer_id)
    1              0.000008         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    1   0.000898   0.000012         call call(l:Callback, [a:timer_id] + l:args)
    1              0.000001     endif

FUNCTION  <SNR>85_filename()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 1 time
Total time:   0.000387
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000387   0.000009   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  ale#Queue()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:123
Called 1 time
Total time:   4.825987
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000002     if a:0 > 2
                                    throw 'too many arguments!'
    1              0.000001     endif
                            
    1              0.000004     let l:buffer = get(a:000, 1, v:null)
                            
    1              0.000002     if l:buffer is v:null
    1              0.000003         let l:buffer = bufnr('')
    1              0.000001     endif
                            
    1              0.000004     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    1              0.000001     endif
                            
    1   0.000141   0.000007     if ale#ShouldDoNothing(l:buffer)
                                    return
    1              0.000001     endif
                            
                                " Default linting_flag to ''
    1              0.000003     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    1              0.000001     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
    1              0.000000     endif
                            
    1              0.000001     if a:delay > 0
                                    let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000001     else
    1   4.825803   0.000011         call s:Lint(l:buffer, l:should_lint_file, 0)
    1              0.000001     endif

FUNCTION  <lambda>14()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/cppcheck.vim:22
Called 1 time
Total time:   0.000020
 Self time:   0.000004

count  total (s)   self (s)
                            return ale#Var(b, 'c_cppcheck_executable')

FUNCTION  <SNR>119_convert()
    Defined: ~/.vim_runtime/sources_non_forked/lightline.vim/autoload/lightline.vim:338
Called 22 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   22              0.000066   if !has_key(s:lightline.component_expand, a:name)
   22              0.000074     return [[[a:name], 0, a:index, a:index]]
                              else
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
                              endif

FUNCTION  ale#Set()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale.vim:190
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000010     let l:full_name = 'ale_' . a:variable_name
                            
    2              0.000007     if !has_key(g:, l:full_name)
                                    let g:[l:full_name] = a:default
    2              0.000002     endif

FUNCTION  ale#history#Get()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/history.vim:8
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000016     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 1 time
Total time:   0.001416
 Self time:   0.000117

count  total (s)   self (s)
    1   0.001414   0.000115   return gitgutter#utility#getbufvar(a:bufnr, 'enabled') && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>144_GetLinterNames()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:336
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000003     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    1              0.000001     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    1              0.000001     endif
                            
                                " b:ale_linters can be set to a List.
    1              0.000003     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    1              0.000001     endif
                            
                                " Try to get a buffer-local setting for the filetype
    1              0.000002     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    1              0.000001     endif
                            
                                " Try to get a global setting for the filetype
    1              0.000002     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    1              0.000001     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    1              0.000001     if g:ale_linters_explicit
                                    return []
    1              0.000001     endif
                            
                                " Try to get a default setting for the filetype
    1              0.000003     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
    1              0.000001     endif
                            
    1              0.000001     return 'all'

FUNCTION  <SNR>166_CanParseMakefile()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/c.vim:18
Called 2 times
Total time:   0.000415
 Self time:   0.000355

count  total (s)   self (s)
                                " Something somewhere seems to delete this setting in tests, so ensure we
                                " always have a default value.
    2   0.000362   0.000337     call ale#Set('c_parse_makefile', 0)
                            
    2   0.000047   0.000012     return ale#Var(a:buffer, 'c_parse_makefile')

FUNCTION  274()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:136
Called 2 times
Total time:   0.000082
 Self time:   0.000025

count  total (s)   self (s)
    2   0.000079   0.000022   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  <SNR>167_VimErrorCallback()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:78
Called 3 times
Total time:   0.000232
 Self time:   0.000173

count  total (s)   self (s)
    3              0.000012     let l:job = ch_getjob(a:channel)
    3   0.000046   0.000024     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
    3              0.000013     if l:job_id > 0 && has_key(s:job_map, l:job_id)
    3   0.000154   0.000117         call ale#util#GetFunction(s:job_map[l:job_id].err_cb)(l:job_id, a:data)
    3              0.000002     endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:430
Called 7 times
Total time:   0.022317
 Self time:   0.000107

count  total (s)   self (s)
    7              0.000029     let l:Executable = a:linter.executable
                            
    7   0.022278   0.000068     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:88
Called 5 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    5              0.000015     if type(a:string_or_ref) is v:t_string
    1              0.000003         return function(a:string_or_ref)
    4              0.000004     endif
                            
    4              0.000005     return a:string_or_ref

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:419
Called 1 time
Total time:   0.000043
 Self time:   0.000018

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    1   0.000018   0.000005     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    1   0.000018   0.000006     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    1              0.000006     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/util.vim:301
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000002     let l:clear_tempdir = 0
                            
    1              0.000005     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    1              0.000001     endif
                            
    1              0.000001     try
    1              0.000004         let l:name = tempname() " no-custom-checks
    1              0.000001     finally
    1              0.000002         if l:clear_tempdir
                                        let $TMPDIR = ''
    1              0.000001         endif
    1              0.000001     endtry
                            
    1              0.000002     return l:name

FUNCTION  <SNR>148_RunLinter()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/engine.vim:589
Called 7 times
Total time:   4.823979
 Self time:   0.000158

count  total (s)   self (s)
    7              0.000026     if !empty(a:linter.lsp)
    3   0.100081   0.000027         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
    4              0.000003     else
    4   0.022233   0.000032         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    4   4.701614   0.000048         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  ale#path#IsAbsolute()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/path.vim:117
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000011     if has('win32') && a:filename[:0] is# '\'
                                    return 1
    2              0.000002     endif
                            
                                " Check for /foo and C:\foo, etc.
    2              0.000014     return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'

FUNCTION  <SNR>169_ParseInlinedFunctionProblems()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/gcc.vim:29
Called 1 time
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    1              0.000002     let l:output = []
    1              0.000002     let l:pos_match = []
                            
    4              0.000006     for l:line in a:lines
    3              0.000047         let l:match = matchlist(l:line, s:pattern)
                            
    3              0.000012         if !empty(l:match) && !empty(l:pos_match)
                                        call add(l:output, {   'lnum': str2nr(l:pos_match[1]),   'col': str2nr(l:pos_match[2]),   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',   'text': s:RemoveUnicodeQuotes(l:match[5]),})
    3              0.000003         endif
                            
    3              0.000026         let l:pos_match = matchlist(l:line, s:inline_pattern)
    4              0.000004     endfor
                            
    1              0.000001     return l:output

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim_runtime/sources_non_forked/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000017   let ggvars = getbufvar(a:buffer, 'gitgutter')
    3              0.000019   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
    3              0.000007     return ggvars[a:varname]
                              endif
                              if a:0
                                return a:1
                              endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:83
Called 1 time
Total time:   0.001141
 Self time:   0.001131

count  total (s)   self (s)
    1              0.000004     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000003     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000015   0.000005         if ale#util#InSandbox()
                                        return
    1              0.000001         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000002         for l:filename in l:info.file_list
                                        call delete(l:filename)
    1              0.000001         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
    2              0.000003         for l:directory in l:info.directory_list
    1              0.001087             call delete(l:directory, 'rf')
    2              0.000004         endfor
                            
    1              0.000005         call remove(s:buffer_data, a:buffer)
    1              0.000001     endif

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/linter.vim:438
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003     let l:Cwd = get(a:linter, 'cwd', v:null)
                            
    1              0.000004     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  <SNR>169_IsHeaderFile()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/gcc.vim:16
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000011     return a:filename =~? '\v\.(h|hpp)$'

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/command.vim:261
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000005     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000003     if !empty(l:info)
    1              0.000002         let l:new_map = {}
                            
    1              0.000004         for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
    1              0.000002         endfor
                            
    1              0.000002         let l:info.jobs = l:new_map
    1              0.000000     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/cursor.vim:115
Called 3 times
Total time:   0.000221
 Self time:   0.000170

count  total (s)   self (s)
    3              0.000014     let l:buffer = bufnr('')
                            
    3              0.000007     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    3              0.000003     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    3              0.000010     if mode(1) isnot# 'n'
                                    return
    3              0.000002     endif
                            
    3   0.000047   0.000025     call s:StopCursorTimer()
                            
    3              0.000021     let l:pos = getpos('.')[0:2]
                            
    3              0.000008     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
    3              0.000002     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    3              0.000006     if l:pos != w:last_pos
    2   0.000040   0.000011         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    2              0.000004         let w:last_pos = l:pos
    2              0.000012         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    3              0.000002     endif

FUNCTION  ale#handlers#gcc#HandleGCCFormat()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/gcc.vim:104
Called 1 time
Total time:   0.000614
 Self time:   0.000251

count  total (s)   self (s)
    1              0.000002     let l:output = []
                            
    3   0.000223   0.000015     for l:match in ale#util#GetMatches(a:lines, s:pattern)
                                    " Filter out the pragma errors
    2   0.000034   0.000023         if s:IsHeaderFile(bufname(bufnr('')))&& l:match[5][:len(s:pragma_error) - 1] is# s:pragma_error
                                        continue
    2              0.000002         endif
                            
                                    " If the 'error type' is a note, make it detail related to
                                    " the previous error parsed in output
    2              0.000006         if l:match[4] is# 'note'
                                        if !empty(l:output)
                                            if !has_key(l:output[-1], 'detail')
                                                let l:output[-1].detail = l:output[-1].text
                            
                                                " handle macro expansion errors/notes
                                                if l:match[5] =~? '^in expansion of macro \w*\w$'
                                                    " if the macro expansion is in the file we're in, add
                                                    " the lnum and col keys to the previous error
                                                    if l:match[1] is# '<stdin>' && !has_key(l:output[-1], 'col')
                                                        let l:output[-1].lnum = str2nr(l:match[2])
                                                        let l:output[-1].col = str2nr(l:match[3])
                                                    else
                                                        " the error is not in the current file, and since
                                                        " macro expansion errors don't show the full path to
                                                        " the error from the current file, we have to just
                                                        " give out a generic error message
                                                        let l:output[-1].text = 'Error found in macro expansion. See :ALEDetail'
                                                    endif
                                                endif
                                            endif
                            
                                            let l:output[-1].detail = l:output[-1].detail . "\n"   . s:RemoveUnicodeQuotes(l:match[0])
                                        endif
                            
                                        continue
    2              0.000002         endif
                            
    2   0.000179   0.000035         let l:item = {   'lnum': str2nr(l:match[2]),   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',   'text': s:RemoveUnicodeQuotes(l:match[5]),}
                            
    2              0.000007         if !empty(l:match[3])
    2              0.000008             let l:item.col = str2nr(l:match[3])
    2              0.000002         endif
                            
                                    " If the filename is something like <stdin>, <nofile> or -, then
                                    " this is an error for the file we checked.
    2              0.000009         if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
                                        let l:item['filename'] = l:match[1]
    2              0.000002         endif
                            
    2              0.000006         call add(l:output, l:item)
    3              0.000005     endfor
                            
    1              0.000001     return l:output

FUNCTION  <SNR>169_RemoveUnicodeQuotes()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/handlers/gcc.vim:20
Called 2 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    2              0.000004     let l:text = a:text
    2              0.000023     let l:text = substitute(l:text, '[`]', '''', 'g')
    2              0.000015     let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
    2              0.000097     let l:text = substitute(l:text, '[]', '"', 'g')
                            
    2              0.000004     return l:text

FUNCTION  ale_linters#c#cc#GetCommand()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/cc.vim:24
Called 1 time
Total time:   4.646670
 Self time:   0.000079

count  total (s)   self (s)
    1   4.635705   0.000012     let l:cflags = ale#c#GetCFlags(a:buffer, a:output)
    1   0.000027   0.000008     let l:ale_flags = ale#Var(a:buffer, 'c_cc_options')
                            
    1              0.000004     if l:cflags =~# '-std='
                                    let l:ale_flags = substitute(   l:ale_flags,   '-std=\(c\|gnu\)[0-9]\{2\}',   '',   'g')
    1              0.000001     endif
                            
                                " Select the correct language flag depending on the executable, options
                                " and file extension
    1   0.010835   0.000010     let l:executable = ale_linters#c#cc#GetExecutable(a:buffer)
    1   0.000022   0.000007     let l:use_header_lang_flag = ale#Var(a:buffer, 'c_cc_use_header_lang_flag')
    1   0.000018   0.000005     let l:header_exts = ale#Var(a:buffer, 'c_cc_header_exts')
    1   0.000029   0.000011     let l:lang_flag = ale#c#GetLanguageFlag(   a:buffer,   l:executable,   l:use_header_lang_flag,   l:header_exts,   'c')
                            
                                " -iquote with the directory the file is in makes #include work for
                                "  headers in the same directory.
                                "
                                " `-o /dev/null` or `-o null` is needed to catch all errors,
                                " -fsyntax-only doesn't catch everything.
    1   0.000021   0.000013     return '%e -S -x ' . l:lang_flag   . ' -o ' . g:ale#util#nul_file   . ' -iquote %s:h'   . ale#Pad(l:cflags)   . ale#Pad(l:ale_flags) . ' -'

FUNCTION  ale#job#Start()
    Defined: ~/.vim_runtime/sources_non_forked/ale/autoload/ale/job.vim:221
Called 1 time
Total time:   0.012870
 Self time:   0.012847

count  total (s)   self (s)
    1   0.000108   0.000099     call ale#job#ValidateArguments(a:command, a:options)
                            
    1              0.000004     let l:job_info = copy(a:options)
    1              0.000002     let l:job_options = {}
                            
    1              0.000004     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
    1              0.000000     else
    1              0.000006         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
    1              0.000003         if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
    1              0.000000         else
                                        " prevent buffering of output and excessive polling in case close_cb is set
    1              0.000005             let l:job_options.out_cb = {->0}
    1              0.000001         endif
                            
    1              0.000002         if has_key(a:options, 'err_cb')
    1              0.000005             let l:job_options.err_cb = function('s:VimErrorCallback')
                                    else
                                        " prevent buffering of output and excessive polling in case close_cb is set
                                        let l:job_options.err_cb = {->0}
    1              0.000001         endif
                            
    1              0.000002         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
    1              0.000004             let l:job_options.close_cb = function('s:VimCloseCallback')
    1              0.000004             let l:job_options.exit_cb = function('s:VimExitCallback')
    1              0.000001         endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
    1              0.000005         if has('patch-8.1.350')
    1              0.000002             let l:job_options.noblock = 1
    1              0.000000         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
    1              0.012617         let l:job_info.job = job_start(a:command, l:job_options)
    1   0.000042   0.000028         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    1              0.000002     endif
                            
    1              0.000003     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    1              0.000004         let s:job_map[l:job_id] = l:job_info
    1              0.000001     endif
                            
    1              0.000001     return l:job_id

FUNCTION  <lambda>9()
    Defined: ~/.vim_runtime/sources_non_forked/ale/ale_linters/c/ccls.vim:8
Called 1 time
Total time:   0.000021
 Self time:   0.000005

count  total (s)   self (s)
                            return ale#Var(b, 'c_ccls_executable')

FUNCTION  <SNR>106_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim82/plugin/matchparen.vim:40
Called 3 times
Total time:   0.001935
 Self time:   0.001897

count  total (s)   self (s)
                              " Remove any previous match.
    3   0.000058   0.000020   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    3              0.000015   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    3              0.000001   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    3              0.000009   let c_lnum = line('.')
    3              0.000010   let c_col = col('.')
    3              0.000005   let before = 0
                            
    3              0.000009   let text = getline(c_lnum)
    3              0.000126   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    3              0.000009   if empty(matches)
                                let [c_before, c] = ['', '']
    3              0.000002   else
    3              0.000015     let [c_before, c] = matches[1:2]
    3              0.000003   endif
    3              0.000125   let plist = split(&matchpairs, '.\zs[:,]')
    3              0.000011   let i = index(plist, c)
    3              0.000005   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000008     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    1              0.000002       let before = strlen(c_before)
    1              0.000001       let c = c_before
    1              0.000003       let i = index(plist, c)
    2              0.000002     endif
    2              0.000003     if i < 0
                                  " not found, nothing to do
    1              0.000001       return
    1              0.000001     endif
    2              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000003   if i % 2 == 0
    2              0.000003     let s_flags = 'nW'
    2              0.000007     let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
    2              0.000001   endif
    2              0.000004   if c == '['
                                let c = '\['
                                let c2 = '\]'
    2              0.000002   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000003   if before > 0
    1              0.000004     let has_getcurpos = exists("*getcurpos")
    1              0.000002     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    1              0.000003       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    1              0.000001     endif
    1              0.000004     call cursor(c_lnum, c_col - before)
    2              0.000002   endif
                            
    2              0.000014   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    2              0.000002   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    2              0.000010     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    2              0.000002     try
    2              0.000505       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    2              0.000002     endtry
    2              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    2              0.000006   let stoplinebottom = line('w$')
    2              0.000004   let stoplinetop = line('w0')
    2              0.000004   if i % 2 == 0
    2              0.000005     let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
    2              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000008   if mode() == 'i' || mode() == 'R'
    1              0.000005     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    1              0.000001   else
    1              0.000004     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000001   endif
    2              0.000002   try
    2              0.000555     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    2              0.000001   endtry
                            
    2              0.000004   if before > 0
    1              0.000001     if has_getcurpos
    1              0.000004       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    1              0.000001     endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000006   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000006     if exists('*matchaddpos')
    2              0.000043       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    2              0.000000     endif
    2              0.000004     let w:paren_hl_on = 1
    2              0.000001   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   4.825987   0.000061  ale#Queue()
    1   4.825792   0.000069  <SNR>133_Lint()
    1   4.825288   0.000138  ale#engine#RunLinters()
    1   4.825004   0.000378  <SNR>148_GetLintFileValues()
    1   4.824545   0.000366  <SNR>148_RunLinters()
    7   4.823979   0.000158  <SNR>148_RunLinter()
    4   4.701566   0.000364  <SNR>148_RunIfExecutable()
    5   4.666324   4.639300  ale#c#FindCompileCommands()
    1   4.649169   0.000012  ale#linter#GetCommand()
    1   4.649157   0.000009  <lambda>8()
    1   4.649148   0.002410  ale#c#RunMakeCommand()
    1   4.646670   0.000079  ale_linters#c#cc#GetCommand()
    1   4.635693   0.000077  ale#c#GetCFlags()
    3   0.100054   0.000045  ale#lsp_linter#CheckWithLSP()
    3   0.100009   0.000447  ale#lsp_linter#StartLSP()
    9   0.092135   0.091731  ale#engine#IsExecutable()
   14   0.067151             ale#path#FindNearestFile()
    3   0.063620   0.000218  ale#lsp_linter#FindProjectRoot()
    4   0.059708   0.000327  ale#c#FindProjectRoot()
    3   0.035826   0.000184  <SNR>150_StartIfExecutable()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    5   4.666324   4.639300  ale#c#FindCompileCommands()
    9   0.092135   0.091731  ale#engine#IsExecutable()
   14              0.067151  ale#path#FindNearestFile()
    1   0.013297   0.013227  gitgutter#async#execute()
    1   0.012870   0.012847  ale#job#Start()
   16   0.006087   0.004832  fugitive#Head()
    1   4.649148   0.002410  ale#c#RunMakeCommand()
    5              0.002016  <SNR>85_abs_path()
    4   0.004351   0.001970  <SNR>119_line()
    3   0.001935   0.001897  <SNR>106_Highlight_Matching_Pair()
   32              0.001806  FugitiveGitDir()
   11              0.001713  lightline#link()
    8   0.001830   0.001674  <SNR>119_expand()
    1              0.001405  ale#cursor#Echom()
    1   0.001141   0.001131  ale#command#RemoveManagedFiles()
   65              0.001057  ale#Var()
    3   0.003236   0.000834  ale#cursor#EchoCursorWarning()
    1              0.000764  ale#util#Writefile()
    5   0.000772   0.000665  ale#path#Upwards()
    1   0.014543   0.000620  ale#c#FindLocalHeaderPaths()

